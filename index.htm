<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>أزياء برغموت</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @keyframes fadeIn {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }
      .animate-fade-in {
        animation: fadeIn 0.5s ease-out forwards;
      }
      body {
        overscroll-behavior-y: contain;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.1.1/client",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.17.0"
  }
}
</script>
</head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module">
import React, { useState, useCallback, useRef, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import { GoogleGenAI, Modality } from "@google/genai";

// START: constants.ts
const translations = {
    ar: { appTitle: "أزياء برغموت", male: "ذكر", female: "أنثى", nextStep: "صورتك الشخصية", chooseImage: "اختر صورة", loading: "جاري التبديل", undo: "تراجع", redo: "تقدم", reset: "إعادة تعيين", save: "حفظ الصورة", back: "العودة للخلف", chooseSourceFor: "اختر", gallery: "الاختيار من المعرض", camera: "التقاط صورة بالكاميرا", virtual: "اختيار افتراضي", cancel: "إلغاء", chooseAbayaType: "اختر نوع العباية", abayaOpen: "ستايل", abayaClosed: "زينبية", chooseVirtual: "اختر", chooseColor: "اختر اللون", apply: "تطبيق", capture: "التقاط", close: "إغلاق", imageLoadError: "حدث خطأ أثناء تحميل الصورة.", cameraError: "لا يمكن الوصول إلى الكاميرا. يرجى التحقق من الأذونات.", unexpectedError: "حدث خطأ غير متوقع.", uploadFirst: "الرجاء تحميل صورة أساسية أولاً.", clickToExtract: "انقر على العنصر لاستخراجه", apiError: "خطأ في الواجهة البرمجية: {message}", safetyError: "فشل إنشاء الصورة بسبب سياسات السلامة. حاول استخدام صورة أو وصف مختلف.", apiKeyMissing: "مفتاح الواجهة البرمجية غير مُعد. لا يمكن للتطبيق الاتصال بالخدمة.", noImageFound: "لم يتم العثور على صورة في استجابة النموذج. قد يكون المحتوى غير مناسب.", shirt: "قميص", pants: "بنطرون", shoes: "حذاء", shawl: "مشمر", hat: "شفقة", glasses: "نظارات", mask: "كمامة", hijab: "ربطة", abaya: "عباية", dress: "فستان", jubba: "جبة", handbag: "جنطة", customItem: "اضافات اخرى", tie: "رباط", watch: "الساعة", classic: "كلاسيكية", aviator: "طيار", round: "دائرية", medical: "طبية", surgical: "جراحية", cloth: "قماشية", kn95: "KN95", cap: "كاب", fedora: "فيدورا", beret: "بيريه", setupApiKeyTitle: "إعداد مفتاح الواجهة البرمجية", updateApiKeyTitle: "تحديث مفتاح الواجهة البرمجية", apiKeyPlaceholder: "أدخل مفتاحك هنا", saveApiKey: "حفظ المفتاح", getApiKeyLink: "احصل على مفتاح من Google AI Studio", apiKeySaved: "تم حفظ المفتاح بنجاح!", apiKeySet: "المفتاح مُفعّل", changeApiKey: "تغيير المفتاح", apiKeyMissingTitle: "مطلوب مفتاح الواجهة البرمجية", apiKeyMissingDesc: "يرجى إضافة مفتاحك في القسم أدناه للمتابعة.", describeItem: "صف العنصر أو اطلب شيئاً جديداً", promptPlaceholder: "اختياري: أضف وصفاً أو اطلب أي شيء (سيارة، قطة...). أضف @ لطلب خيالي.", pressBackAgainToExit: "اضغط مرة أخرى للخروج", uploadSourceImage: "ارفع صورة المصدر", QUOTA_EXCEEDED: "لقد تجاوزت الحد اليومي لمفتاح استوديو كوكل حاول مجددا بعد 24 ساعة او اجلب مفتاح من حساب اخر", graduationGown: "زي التخرج", chador: "چادر", dishdasha: "دشداشة", jacket: "سترة", misuseWarningTitle: "تحذير! .. إساءة استخدام", misuseWarningBody: "برغموت يمنع محاولات الاستهزاء والتشهير وفي حال تكرار العملية قد يتم حظرك من استخدام التطبيق.", replace: "تبديل" },
    en: { appTitle: "Bergamot Fashion", male: "Male", female: "Female", nextStep: "Your Personal Photo", chooseImage: "Choose Image", loading: "Loading", undo: "Undo", redo: "Redo", reset: "Reset", save: "Save Image", back: "Go Back", chooseSourceFor: "Choose source for", gallery: "Select from Gallery", camera: "Capture with Camera", virtual: "Choose Virtual", cancel: "Cancel", chooseAbayaType: "Choose Abaya Type", abayaOpen: "Style", abayaClosed: "Zainabiya", chooseVirtual: "Choose", chooseColor: "Choose Color", apply: "Apply", capture: "Capture", close: "Close", imageLoadError: "Error loading the image.", cameraError: "Could not access the camera. Please check permissions.", unexpectedError: "An unexpected error occurred.", uploadFirst: "Please upload a base image first.", clickToExtract: "Click the item to extract it", apiError: "API Error: {message}", safetyError: "Image generation failed due to safety policies. Try a different image or description.", apiKeyMissing: "API Key is not configured. The application cannot connect to the service.", noImageFound: "No image found in the model's response. The content might be inappropriate.", shirt: "Shirt", pants: "Pants", shoes: "Shoes", shawl: "Shawl", hat: "Hat", glasses: "Glasses", mask: "Mask", hijab: "Hijab", abaya: "Abaya", dress: "Dress", jubba: "Jubba", handbag: "Handbag", customItem: "Add Item", tie: "Tie", watch: "Watch", classic: "Classic", aviator: "Aviator", round: "Round", medical: "Medical", surgical: "Surgical", cloth: "Cloth", kn95: "KN95", cap: "Cap", fedora: "Fedora", beret: "Beret", setupApiKeyTitle: "API Key Setup", updateApiKeyTitle: "Update API Key", apiKeyPlaceholder: "Enter your key here", saveApiKey: "Save Key", getApiKeyLink: "Get a key from Google AI Studio", apiKeySaved: "API Key saved successfully!", apiKeySet: "API Key is Set", changeApiKey: "Change Key", apiKeyMissingTitle: "API Key Required", apiKeyMissingDesc: "Please add your key in the section below to proceed.", describeItem: "Describe the item or request something new", promptPlaceholder: "Optional: Add a description or request anything (car, cat...). Add @ for creative requests.", pressBackAgainToExit: "Press back again to exit", uploadSourceImage: "Upload Source Image", QUOTA_EXCEEDED: "You have exceeded the daily limit for your Google Studio key. Please try again in 24 hours or use a key from a different account.", graduationGown: "Graduation Gown", chador: "Chador", dishdasha: "Dishdasha", jacket: "Jacket", misuseWarningTitle: "Warning! Misuse", misuseWarningBody: "Bergamot prohibits attempts at ridicule and defamation. Repeated attempts may result in a ban from using the application.", replace: "Replace" },
    fa: { appTitle: "فشن برغموت", male: "مرد", female: "زن", nextStep: "عکس شخصی شما", chooseImage: "انتخاب تصویر", loading: "در حال بارگذاری", undo: "واگرد", redo: "بازانجام", reset: "بازنشانی", save: "ذخیره تصویر", back: "بازگشت", chooseSourceFor: "انتخاب منبع برای", gallery: "انتخاب از گالری", camera: "گرفتن عکس با دوربین", virtual: "انتخاب مجازی", cancel: "لغو", chooseAbayaType: "انتخاب نوع عبا", abayaOpen: "استایل", abayaClosed: "زینبیه", chooseVirtual: "انتخاب کنید", chooseColor: "انتخاب رنگ", apply: "اعمال", capture: "گرفتن عکس", close: "بستن", imageLoadError: "خطا در بارگذاری تصویر.", cameraError: "دسترسی به دوربین امکان‌پذیر نیست. لطفاً مجوزها را بررسی کنید.", unexpectedError: "یک خطای غیرمنتظره رخ داد.", uploadFirst: "لطفاً ابتدا یک تصویر پایه بارگذاری کنید.", clickToExtract: "روی مورد کلیک کنید تا استخراج شود", apiError: "خطای API: {message}", safetyError: "ایجاد تصویر به دلیل سیاست‌های ایمنی ناموفق بود. تصویر یا توضیحات دیگری را امتحان کنید.", apiKeyMissing: "کلید API پیکربندی نشده است. برنامه نمی‌تواند به سرویس متصل شود.", noImageFound: "تصویری در پاسخ مدل یافت نشد. ممکن است محتوا نامناسب باشد.", shirt: "پیراهن", pants: "شلوار", shoes: "کفش", shawl: "شال", hat: "کلاه", glasses: "عینک", mask: "ماسک", hijab: "روسری", abaya: "عبا", dress: "لباس مجلسی", jubba: "جبه", handbag: "کیف دستی", customItem: "افزودن آیتم", tie: "کراوات", watch: "ساعت", classic: "کلاسیک", aviator: "خلبانی", round: "گرد", medical: "طبی", surgical: "جراحی", cloth: "پارچه‌ای", kn95: "KN95", cap: "کلاه لبه‌دار", fedora: "فدورا", beret: "بره", setupApiKeyTitle: "تنظیم کلید API", updateApiKeyTitle: "به‌روزرسانی کلید API", apiKeyPlaceholder: "کلید خود را اینجا وارد کنید", saveApiKey: "ذخیره کلید", getApiKeyLink: "دریافت کلید از Google AI Studio", apiKeySaved: "کلید API با موفقیت ذخیره شد!", apiKeySet: "کلید API تنظیم شده است", changeApiKey: "تغییر کلید", apiKeyMissingTitle: "کلید API مورد نیاز است", apiKeyMissingDesc: "لطفاً برای ادامه، کلید خود را در بخش زیر اضافه کنید.", describeItem: "مورد را توصیف کنید یا چیز جدیدی درخواست کنید", promptPlaceholder: "اختیاری: توضیحی اضافه کنید یا هر چیزی را درخواست کنید (ماشین، گربه...). برای درخواست‌های خلاقانه، @ اضافه کنید.", pressBackAgainToExit: "برای خروج دوباره بازگشت را فشار دهید", uploadSourceImage: "آپلود تصویر منبع", QUOTA_EXCEEDED: "شما از حد مجاز روزانه برای کلید Google Studio خود فراتر رفته‌اید. لطفاً پس از 24 ساعت دوباره امتحان کنید یا از کلید حساب دیگری استفاده کنید.", graduationGown: "لباس فارغ التحصیلی", chador: "چادر", dishdasha: "دشداشه", jacket: "کت", misuseWarningTitle: "هشدار! سوء استفاده", misuseWarningBody: "برغموت تلاش برای تمسخر و افترا را ممنوع می‌کند. تکرار این عمل ممکن است منجر به مسدود شدن شما از استفاده از برنامه شود.", replace: "جایگزینی" }
};
const MALE_CATEGORIES = [
    { id: 'shirt', nameKey: 'shirt', icon: 'ShirtIcon', virtual: false },
    { id: 'jacket', nameKey: 'jacket', icon: 'JacketIcon', virtual: false },
    { id: 'pants', nameKey: 'pants', icon: 'PantsIcon', virtual: false },
    { id: 'tie', nameKey: 'tie', icon: 'TieIcon', virtual: false },
    { id: 'watch', nameKey: 'watch', icon: 'WatchIcon', virtual: false },
    { id: 'shoes', nameKey: 'shoes', icon: 'ShoesIcon', virtual: false },
    { id: 'shawl', nameKey: 'shawl', icon: 'ShawlIcon', virtual: false },
    { id: 'hat', nameKey: 'hat', icon: 'HatIcon', virtual: true },
    { id: 'glasses', nameKey: 'glasses', icon: 'GlassesIcon', virtual: true },
    { id: 'mask', nameKey: 'mask', icon: 'MaskIcon', virtual: true },
    { id: 'dishdasha', nameKey: 'dishdasha', icon: 'DishdashaIcon', virtual: false },
    { id: 'graduationGown', nameKey: 'graduationGown', icon: 'GraduationCapIcon', virtual: false },
    { id: 'customItem', nameKey: 'customItem', icon: 'CustomItemIcon', virtual: false },
];
const FEMALE_CATEGORIES = [
    { id: 'hijab', nameKey: 'hijab', icon: 'HijabIcon', virtual: false },
    { id: 'abaya', nameKey: 'abaya', icon: 'AbayaIcon', virtual: true },
    { id: 'dress', nameKey: 'dress', icon: 'DressIcon', virtual: false },
    { id: 'jubba', nameKey: 'jubba', icon: 'JubbaIcon', virtual: false },
    { id: 'shirt', nameKey: 'shirt', icon: 'ShirtIcon', virtual: false },
    { id: 'jacket', nameKey: 'jacket', icon: 'JacketIcon', virtual: false },
    { id: 'pants', nameKey: 'pants', icon: 'PantsIcon', virtual: false },
    { id: 'shoes', nameKey: 'shoes', icon: 'ShoesIcon', virtual: false },
    { id: 'handbag', nameKey: 'handbag', icon: 'HandbagIcon', virtual: false },
    { id: 'shawl', nameKey: 'shawl', icon: 'ShawlIcon', virtual: false },
    { id: 'hat', nameKey: 'hat', icon: 'HatIcon', virtual: true },
    { id: 'glasses', nameKey: 'glasses', icon: 'GlassesIcon', virtual: true },
    { id: 'mask', nameKey: 'mask', icon: 'MaskIcon', virtual: true },
    { id: 'graduationGown', nameKey: 'graduationGown', icon: 'GraduationCapIcon', virtual: false },
    { id: 'chador', nameKey: 'chador', icon: 'ChadorIcon', virtual: false },
    { id: 'customItem', nameKey: 'customItem', icon: 'CustomItemIcon', virtual: false },
];
const VIRTUAL_ITEMS = {
    glasses: [
        { nameKey: 'classic', prompt: 'classic wayfarer sunglasses' },
        { nameKey: 'aviator', prompt: 'silver-framed aviator sunglasses' },
        { nameKey: 'round', prompt: 'round, retro-style sunglasses' },
        { nameKey: 'medical', prompt: 'modern, thin-framed prescription eyeglasses with clear lenses' },
    ],
    mask: [
        { nameKey: 'surgical', prompt: 'a surgical-style face mask' },
        { nameKey: 'cloth', prompt: 'a simple cloth face mask' },
        { nameKey: 'kn95', prompt: 'a KN95 respirator-style mask' },
    ],
    hat: [
        { nameKey: 'cap', prompt: 'a baseball cap' },
        { nameKey: 'fedora', prompt: 'a classic fedora hat' },
        { nameKey: 'beret', prompt: 'a beret hat' },
    ],
};
// END: constants.ts

// START: utils/fileUtils.ts
const toBase64 = (file) => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
        const result = reader.result;
        resolve(result.split(',')[1]);
    };
    reader.onerror = (error) => reject(error);
});
// END: utils/fileUtils.ts

// START: services/geminiService.ts
const buildGenerationPrompt = (
    category,
    options,
    wornItems,
    gender,
    isReplacing
) => {
    const itemsForPrompt = isReplacing ? wornItems.filter(id => id !== category.id) : wornItems;
    const layeringPrompt = itemsForPrompt.length > 0
        ? `Note: The person is already wearing: ${itemsForPrompt.join(', ')}. Ensure the new item layers realistically on top or underneath as appropriate.`
        : 'The person is not wearing any other items of note.';

    const customPromptText = options.customPrompt?.replace('@', '').trim() ?? '';

    const baseInstructions = `
**MISSION**: Your task is to perform a hyper-realistic virtual try-on. The goal is flawless photorealism and seamless integration. Adherence to these rules is ABSOLUTE & NON-NEGOTIABLE.

**CORE DIRECTIVES**:
1.  **IDENTITY PRESERVATION**: The person in [BASE_IMAGE]—including their face, hair, body shape, pose, and skin tone—MUST remain UNCHANGED. Do not alter their identity or expression.
2.  **BACKGROUND INTEGRITY**: The background, environment, and all other objects in [BASE_IMAGE] MUST remain completely UNALTERED.
3.  **PHYSICS & REALISM**:
    *   **Fabric Drape & Fit**: The new clothing item must drape, fold, and stretch naturally according to the person's body and pose. It must look like it truly fits them.
    *   **Lighting & Shadow**: The item MUST perfectly match the lighting direction, hardness, color temperature, and intensity of the original [BASE_IMAGE]. Create realistic, subtle shadows and highlights on the new item, and cast realistic shadows from the item onto the person's body and vice-versa.
    *   **Perspective & Texture**: The item must be scaled and warped to precisely match the camera's perspective. Preserve or generate a realistic texture for the material.
`;

    const itemDescriptionMap = {
        shirt: 'the shirt', pants: 'the pants', tie: 'the necktie', watch: 'the wristwatch', shoes: 'the pair of shoes', shawl: 'the shawl or scarf', hijab: 'the hijab', dress: 'the dress', handbag: 'the handbag', jacket: 'the jacket, vest, or blazer', jubba: "the women's jubba", graduationGown: 'the graduation gown', dishdasha: "the dishdasha", chador: "the chador", abaya: "the abaya"
    };
    const aiItemName = itemDescriptionMap[category.id] || `the ${category.id}`;

    if (category.id === 'customItem') {
        if (options.clothingFile && options.clickCoords) {
            const { x, y, width, height } = options.clickCoords;
            const coordsText = `(x: ${(x / width).toFixed(3)}, y: ${(y / height).toFixed(3)})`;
            const itemIdentifier = customPromptText ? `the item described as "${customPromptText}"` : 'the object';
            return `
**TASK**: Identify ${itemIdentifier} in [SOURCE_IMAGE] (indicated by a click near coordinates ${coordsText}). Extract this object and masterfully place it onto the person in [BASE_IMAGE].
${baseInstructions}
**LAYERING**: ${layeringPrompt}
`;
        } else if (customPromptText && !options.clothingFile) {
             const creativeMarker = options.customPrompt?.includes('@');
             const creativityPrompt = creativeMarker ? "\n**CREATIVE FREEDOM**: The '@' symbol was used, allowing for a more imaginative or fantastical interpretation of the request, while still respecting the core directives." : "";
             return `
**TASK**: Execute a precise and localized edit on [BASE_IMAGE] based on this request: "${customPromptText}".
**CORE DIRECTIVES**:
1.  **MINIMAL CHANGE**: Alter ONLY what is explicitly requested. The rest of the person and the entire background must remain IDENTICAL to the original.
2.  **REALISM**: The edit must be photorealistic and seamlessly integrated.
${creativityPrompt}
**LAYERING**: ${layeringPrompt}
`;
        }
        return '';
    } else {
        if (options.clothingFile) {
            return `
**TASK**: Extract ${aiItemName} from [SOURCE_IMAGE] and expertly fit it onto the person in [BASE_IMAGE]. This is a professional virtual try-on.
${baseInstructions}
**INSTRUCTION**: This item should replace any existing clothing it would naturally cover.
**LAYERING**: ${layeringPrompt}
`;
        } else if (options.virtualPrompt || (category.id === 'abaya' && options.abayaType)) {
            const action = isReplacing ? `Replace the person's existing ${aiItemName} with` : 'Add';
            let virtualItemDescription = options.virtualPrompt;
            if (category.id === 'abaya' && options.abayaType) {
                const abayaStyle = options.abayaType === 'open' ? 'an open-front style abaya' : 'a fully closed (Zainabiya style) abaya';
                virtualItemDescription = `an elegant black ${abayaStyle}`;
            }

            return `
**TASK**: Generate and seamlessly integrate a new, hyper-realistic "${virtualItemDescription}" onto the person in [BASE_IMAGE].
${baseInstructions}
**INSTRUCTION**: ${action} this new item.
**LAYERING**: ${layeringPrompt}
`;
        }
    }
    console.error(`Could not build prompt for category '${category.id}' with options:`, options);
    return '';
};


const generateImage = async (
    apiKey,
    baseImage,
    clothingImage,
    category,
    options,
    wornItems,
    gender,
    isReplacing,
) => {
  if (!apiKey) throw new Error("API_KEY_MISSING");

  const ai = new GoogleGenAI({ apiKey });
  const model = 'gemini-2.5-flash-image-preview';

  const prompt = buildGenerationPrompt(category, options, wornItems, gender, isReplacing);
  if (!prompt) {
      console.error("Prompt generation failed for", category, options);
      throw new Error("unexpectedError");
  }

  const parts = [
    { inlineData: { mimeType: baseImage.mimeType, data: baseImage.data } },
  ];

  if (clothingImage) {
    parts.push({ inlineData: { mimeType: clothingImage.mimeType, data: clothingImage.data } });
  }
  
  parts.push({ text: prompt });

  try {
    const response = await ai.models.generateContent({
      model: model,
      contents: { parts: parts },
      config: {
        responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
    });
    
    if (response.candidates?.[0]?.finishReason && response.candidates[0].finishReason !== 'STOP') {
        if (response.candidates[0].finishReason === 'SAFETY') {
            throw new Error('safetyError');
        }
        console.warn(`Generation stopped for reason: ${response.candidates[0].finishReason}`);
        throw new Error('unexpectedError');
    }
    
    const imagePart = response.candidates?.[0]?.content?.parts?.find(part => part.inlineData);

    if (imagePart?.inlineData?.data) {
      return imagePart.inlineData.data;
    } else {
      const textPart = response.candidates?.[0]?.content?.parts?.find(part => part.text);
      if (textPart?.text?.toLowerCase().includes("quota")) {
          throw new Error("QUOTA_EXCEEDED");
      }
      console.warn("No image found in model response. Text part:", textPart?.text || "N/A");
      throw new Error("noImageFound");
    }
  } catch (e) {
    console.error("Gemini API call failed:", e);
    if (e.message && ['safetyError', 'noImageFound', 'QUOTA_EXCEEDED', 'API_KEY_MISSING', 'unexpectedError'].includes(e.message)) {
        throw e;
    }
    const errorMessage = e.toString().toLowerCase();
    if (errorMessage.includes('api key not valid')) {
        throw new Error("API_KEY_MISSING");
    }
    if (errorMessage.includes('429') || errorMessage.includes("quota")) {
        throw new Error("QUOTA_EXCEEDED");
    }
    throw new Error(e.message || 'unexpectedError');
  }
};
// END: services/geminiService.ts

// START: hooks/useLocalization.ts
const useLocalization = () => {
    const [language, setLanguage] = useState('ar');

    const t = useCallback((key) => {
        return translations[language]?.[key] || key;
    }, [language]);

    useEffect(() => {
        document.documentElement.lang = language;
        document.documentElement.dir = language === 'ar' || language === 'fa' ? 'rtl' : 'ltr';
        document.title = t('appTitle');
    }, [language, t]);

    const LANG_MAP = { ar: 'العربية', en: 'English', fa: 'فارسی' };
    const getNextLangName = () => language === 'ar' ? LANG_MAP['en'] : language === 'en' ? LANG_MAP['fa'] : LANG_MAP['ar'];

    return { language, setLanguage, t, getNextLangName };
};
// END: hooks/useLocalization.ts

// START: hooks/useApiKey.ts
const useApiKey = (t) => {
    const [apiKey, setApiKey] = useState(() => {
        try {
            const key = localStorage.getItem('gemini_api_key');
            return (key && key !== 'null' && key !== 'undefined') ? key : null;
        } catch (error) {
            console.error("Could not access localStorage:", error);
            return null;
        }
    });
    const [toastMessage, setToastMessage] = useState('');

    const handleSaveKey = (key) => {
        try {
            localStorage.setItem('gemini_api_key', key);
            setApiKey(key);
            setToastMessage(t('apiKeySaved'));
            setTimeout(() => setToastMessage(''), 3000);
        } catch (error) {
            console.error("Could not save API key to localStorage:", error);
            setToastMessage('Error saving API key.');
            setTimeout(() => setToastMessage(''), 3000);
        }
    };

    return { apiKey, setApiKey, toastMessage, setToastMessage, handleSaveKey };
};
// END: hooks/useApiKey.ts

// START: components/Icons.tsx
const ShirtIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M18.33 4.14C18.23 4.05 18.1 4 18 4h-3.5c-.28 0-.5.22-.5.5s.22.5.5.5H17.09l-2.4 2.4C14.32 7.03 13.68 6.9 13.14 7L12 7.64l-1.14-.64c-.54-.3-1.18-.17-1.55.2l-2.4 2.4V9.5c0-.28-.22-.5-.5-.5s-.5.22-.5.5V13c0 .1.05.23.14.33l4 4c.1.1.23.17.36.17s.26-.07.36-.17l4-4c.09-.1.14-.23.14-.33V9.5c0-.28-.22-.5-.5-.5s-.5.22-.5.5v.09l-2.4-2.4c.37-.37.5-1.01.2-1.55L12.36 5 13 4.64c.54-.3 1.18-.17 1.55.2l2.4 2.4V6.5c0-.28.22-.5.5-.5s.5.22.5.5v-2.33c0-.1-.05-.23-.14-.33z" }));
const JacketIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M18 7c0-1.1-.9-2-2-2h-2V4c0-.55-.45-1-1-1s-1 .45-1 1v1H8c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7zm-2 10H8V7h8v10zM12 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" }));
const PantsIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12.5 1.5c-4.69 0-8.5 3.81-8.5 8.5v10c0 .55.45 1 1 1s1-.45 1-1V10c0-3.69 3.31-7.5 6.5-7.5s6.5 3.81 6.5 7.5v10c0 .55.45 1 1 1s1-.45 1-1V10c0-4.69-3.81-8.5-8.5-8.5z" }));
const ShoesIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M20.5 13.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM3.5 13.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm11-4.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm-11 0c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" }));
const HatIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-12h2v4h-2zm0 6h2v2h-2z" }));
const GlassesIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" }));
const MaskIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8zm-3-9h6v2H9zm0 4h6v2H9z" }));
const HijabIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" }));
const AbayaIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M6 3h12v2H6zm0 4h12v2H6zm0 4h12v2H6zm0 4h12v2H6zm0 4h12v2H6z" }));
const ChadorIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M21.8,11.2C21.2,6.4,17.1,3,12,3C6.9,3,2.8,6.4,2.2,11.2L2,12.3V20c0,0.6,0.4,1,1,1h18c0.6,0,1-0.4,1-1v-7.7 L21.8,11.2z M12,5c3.9,0,7.2,2.5,7.8,6H4.2C4.8,7.5,8.1,5,12,5z" }));
const DressIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 3L4 9v12h16V9L12 3zm4 16h-3v-4H9v4H5v-8.59L12 6.29l7 5.12V19z" }));
const JubbaIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 2l-10 5v10l10 5 10-5V7l-10-5zm0 2.24L19.5 8 12 11.76 4.5 8 12 4.24zM4 10.5l8 4.5 8-4.5V17l-8 4.5-8-4.5v-6.5z" }));
const HandbagIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M18 6h-2c0-2.21-1.79-4-4-4S8 3.79 8 6H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6-2c1.1 0 2 .9 2 2h-4c0-1.1.9-2 2-2zm6 12H6V8h2v2c0 .55.45 1 1 1s1-.45 1-1V8h4v2c0 .55.45 1 1 1s1-.45 1-1V8h2v10z" }));
const ShawlIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M19.41 7.41L18 6l-6 6-6-6-1.41 1.41L12 10.83l7.41-3.42zM12 13.17L4.59 9.58 3 11l9 4 9-4-1.59-1.42L12 13.17z" }));
const CustomItemIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M20.5,11H19V7a2,2,0,0,0-2-2H13V3.5A1.5,1.5,0,0,0,11.5,2h-3A1.5,1.5,0,0,0,7,3.5V5H5A2,2,0,0,0,3,7v4H3.5a1.5,1.5,0,0,0,0,3H3v4a2,2,0,0,0,2,2h3.5v1.5a1.5,1.5,0,0,0,1.5,1.5h3a1.5,1.5,0,0,0,1.5-1.5V21H17a2,2,0,0,0,2-2V15h.5a1.5,1.5,0,0,0,0-3M5,7H17v4H5Zm12,12H5V13H17Z" }));
const TieIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 2L8 6.98V10h8v-3.02L12 2zm-2.06 9.01L12 13.06l2.06-2.05L16 11.5V22H8v-10.5l1.94-.49z" }));
const WatchIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M20 12c0-2.54-1.19-4.81-3.04-6.27L16 0h-8l-.95 5.73C5.19 7.19 4 9.46 4 12s1.19 4.81 3.04 6.27L8 24h8l.96-5.73C18.81 16.81 20 14.54 20 12zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm-1-8h2v5h-2v-5z" }));
const DishdashaIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M16,3 L15,3 L15,2 C15,2 14,1 12,1 C10,1 9,2 9,2 L9,3 L8,3 C6.89,3 6,3.89 6,5 L6,7 L18,7 L18,5 C18,3.89 17.11,3 16,3 Z M6,8 L6,21 C6,22.1 6.9,23 8,23 L16,23 C17.1,23 18,22.1 18,21 L18,8 L6,8 Z" }));
const GraduationCapIcon = () => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M21.58,9.55l-9-4.36c-0.34-0.16-0.74-0.16-1.08,0l-9,4.36C2.19,9.71,2,10,2,10.32v3.5c0,0.3,0.18,0.58,0.46,0.71 l2.23,1.07v3.25c0,0.34,0.22,0.64,0.54,0.74l6,1.75c0.06,0.02,0.12,0.03,0.18,0.03s0.12-0.01,0.18-0.03l6-1.75 c0.32-0.09,0.54-0.4,0.54-0.74v-3.25l1.82-0.87H21c0.35,0,0.64-0.29,0.64-0.64V9.86C21.64,9.7,21.61,9.62,21.58,9.55z M12,6.12 l6.7,3.25L12,12.62l-6.7-3.25L12,6.12z M4.69,14.04L4,13.73v-2.71l7.5,3.61v4.45L4.69,16.5V14.04z" }));
const GalleryIcon = ({ className }) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: className }, React.createElement("path", { d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" }));
const CameraIcon = ({ className }) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: className }, React.createElement("circle", { cx: "12", cy: "12", r: "3.2" }), React.createElement("path", { d: "M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z" }));
const IconsMap = { ShirtIcon, PantsIcon, ShoesIcon, HatIcon, GlassesIcon, MaskIcon, HijabIcon, AbayaIcon, DressIcon, JubbaIcon, HandbagIcon, ShawlIcon, CustomItemIcon, TieIcon, WatchIcon, GraduationCapIcon, DishdashaIcon, ChadorIcon, JacketIcon };
// END: components/Icons.tsx

// START: components/Button.tsx
const Button = ({ variant = 'primary', children, className, ...props }) => {
  const baseClasses = "text-white font-bold py-1 px-3 text-xs rounded-md shadow-lg transition-all duration-300 ease-in-out transform focus:outline-none focus:ring-2 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none disabled:transform-none";
  
  const variantClasses = {
    primary: "bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 hover:-translate-y-0.5 focus:ring-blue-400",
    secondary: "bg-gray-600 hover:bg-gray-500 focus:ring-gray-400"
  };

  return React.createElement("button", { className: `${baseClasses} ${variantClasses[variant]} ${className || ''}`, ...props }, children);
};
// END: components/Button.tsx

// START: components/Spinner.tsx
const Spinner = () => React.createElement("div", { className: "border-4 border-gray-500 border-t-blue-500 rounded-full w-12 h-12 animate-spin" });
// END: components/Spinner.tsx

// START: components/ApiKeyManager.tsx
const ApiKeyManager = ({ t, onSave, currentKey }) => {
  const [keyInput, setKeyInput] = useState('');
  const [isEditing, setIsEditing] = useState(!currentKey);

  useEffect(() => {
    if (!currentKey) {
      setIsEditing(true);
    }
  }, [currentKey]);

  const handleSave = () => {
    if (keyInput.trim()) {
      onSave(keyInput.trim());
      setIsEditing(false);
    }
  };

  const editingView = React.createElement("div", { className: "flex flex-col items-center animate-fade-in" },
    React.createElement("h3", { className: "text-lg font-semibold mb-3 text-gray-200" }, currentKey ? t('updateApiKeyTitle') : t('setupApiKeyTitle')),
    React.createElement("input", {
      type: "password",
      value: keyInput,
      onChange: (e) => setKeyInput(e.target.value),
      placeholder: t('apiKeyPlaceholder'),
      className: "w-full max-w-sm bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white mb-3 focus:ring-blue-500 focus:border-blue-500 text-center"
    }),
    React.createElement(Button, { onClick: handleSave, disabled: !keyInput.trim(), className: "text-sm p-2" }, t('saveApiKey')),
    currentKey && React.createElement("button", { onClick: () => setIsEditing(false), className: "mt-3 text-gray-400 text-sm hover:underline" }, t('cancel')),
    React.createElement("a", {
      href: "https://aistudio.google.com/app/apikey",
      target: "_blank",
      rel: "noopener noreferrer",
      className: "mt-3 text-blue-400 hover:text-blue-300 underline"
    }, t('getApiKeyLink'))
  );

  const displayView = React.createElement("div", { className: "flex items-center justify-center gap-4" },
    React.createElement("span", { className: "text-green-400 font-semibold" }, `✓ ${t('apiKeySet')}`),
    React.createElement("button", { onClick: () => { setKeyInput(''); setIsEditing(true); }, className: "text-blue-400 underline text-sm" }, t('changeApiKey'))
  );

  return React.createElement("div", { className: "w-full max-w-4xl mx-auto mt-4 p-4 bg-gray-800/50 border border-gray-700 rounded-xl text-center" },
    isEditing ? editingView : displayView
  );
};
// END: components/ApiKeyManager.tsx

// START: components/modals/ModalWrapper.tsx
const ModalWrapper = ({ title, onClose, children, size = 'xl' }) => {
  const sizeClass = {
    'xl': 'max-w-xl',
    '3xl': 'max-w-3xl',
    'fullscreen': 'w-[95vw] h-[90vh]'
  }[size];

  return React.createElement("div", {
      className: "fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm p-4",
      onClick: onClose
    },
    React.createElement("div", {
        className: `bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 flex flex-col w-full ${sizeClass} text-center animate-fade-in`,
        onClick: (e) => e.stopPropagation()
      },
      title && React.createElement("h2", { className: "text-2xl font-bold mb-6 text-blue-400" }, title),
      React.createElement("div", { className: "space-y-3 flex-1 flex flex-col" }, children)
    )
  );
};
// END: components/modals/ModalWrapper.tsx

// START: components/modals/InputSourceModal.tsx
const InputSourceModal = ({ category, onClose, onGallerySelect, onCameraSelect, onVirtualSelect, t }) => React.createElement(ModalWrapper, { onClose: onClose },
  React.createElement("div", { className: "flex justify-center gap-4" },
    React.createElement(Button, { onClick: onGallerySelect, className: "p-4 aspect-square", "aria-label": t('gallery') },
      React.createElement(GalleryIcon, { className: "w-8 h-8" })
    ),
    React.createElement(Button, { onClick: onCameraSelect, className: "p-4 aspect-square", "aria-label": t('camera') },
      React.createElement(CameraIcon, { className: "w-8 h-8" })
    )
  ),
  category.virtual && React.createElement(Button, { onClick: onVirtualSelect, className: "w-full !text-sm !p-2" }, t('virtual')),
  React.createElement(Button, { onClick: onClose, variant: "secondary", className: "w-full mt-4 !text-sm !p-2" }, t('cancel'))
);
// END: components/modals/InputSourceModal.tsx

// START: components/modals/CustomItemModal.tsx
const DraggableArrowIcon = ({ className }) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", className: className, fill: "#3b82f6", stroke: "#ffffff", strokeWidth: "1" },
    React.createElement("path", { d: "M3.1,3.1L20.9,12L12.9,12.9L3.1,20.9V3.1z" })
);

const CustomItemModal = ({ t, onClose, onSubmit, onLaunchCamera, initialSourceFile }) => {
    const [sourceImage, setSourceImage] = useState(null);
    const [sourceFile, setSourceFile] = useState(null);
    const [promptText, setPromptText] = useState('');
    const [coords, setCoords] = useState(null);
    const [isDragging, setIsDragging] = useState(false);
    const fileInputRef = useRef(null);
    const imageContainerRef = useRef(null);
    
    const toDataURL = useCallback((file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
    }), []);

    useEffect(() => {
        const processFile = async (file) => {
            if (file) {
                try {
                    const dataUrl = await toDataURL(file);
                    setCoords(null);
                    setSourceImage(dataUrl);
                    setSourceFile(file);
                } catch (error) {
                    alert(t('imageLoadError'));
                }
            }
        };
        if (initialSourceFile) {
            processFile(initialSourceFile);
        }
    }, [initialSourceFile, t, toDataURL]);

    const handleFileChange = async (e) => {
        const file = e.target.files?.[0];
        if (file) {
            try {
                const dataUrl = await toDataURL(file);
                setCoords(null);
                setSourceImage(dataUrl);
                setSourceFile(file);
            } catch (error) {
                alert(t('imageLoadError'));
            }
        }
    };
    
    const handleImageLoad = () => {
        if (imageContainerRef.current && !coords) {
            const { clientWidth, clientHeight } = imageContainerRef.current;
            const x = clientWidth / 2;
            const y = clientHeight / 2;
            setCoords({ x, y, width: clientWidth, height: clientHeight, displayX: x, displayY: y });
        }
    };

    const handleDragStart = (e) => {
        e.preventDefault();
        setIsDragging(true);
    };

    const handleDragMove = (e) => {
        if (!isDragging || !imageContainerRef.current) return;
        e.preventDefault();
        const rect = imageContainerRef.current.getBoundingClientRect();
        const touch = 'touches' in e ? e.touches[0] : e;
        const clientX = touch.clientX;
        const clientY = touch.clientY;
        let x = clientX - rect.left;
        let y = clientY - rect.top;
        x = Math.max(0, Math.min(x, rect.width));
        y = Math.max(0, Math.min(y, rect.height));
        setCoords({ x, y, width: rect.width, height: rect.height, displayX: x, displayY: y });
    };

    const handleDragEnd = () => setIsDragging(false);

    const handleSubmit = () => {
        if ((sourceFile && coords) || promptText.trim()) {
            onSubmit({ clothingFile: sourceFile, clickCoords: coords, customPrompt: promptText });
        }
    };
    
    const isValid = (sourceFile && coords) || (!sourceFile && promptText.trim());

    return React.createElement(ModalWrapper, { title: t('customItem'), onClose: onClose },
        sourceImage ? 
            React.createElement("div", {
                ref: imageContainerRef,
                className: "border-2 border-dashed border-gray-600 rounded-lg overflow-hidden relative touch-none",
                onMouseMove: handleDragMove, onTouchMove: handleDragMove, onMouseUp: handleDragEnd,
                onMouseLeave: handleDragEnd, onTouchEnd: handleDragEnd
            },
                React.createElement("img", { src: sourceImage, alt: "Source for item", className: "w-full h-auto select-none", onLoad: handleImageLoad }),
                coords && React.createElement("div", {
                    className: "absolute cursor-move pointer-events-auto",
                    style: { 
                        left: `${coords.displayX}px`, 
                        top: `${coords.displayY}px`, 
                        width: '40px', 
                        height: '40px', 
                        touchAction: 'none',
                        transform: 'translate(-5px, -5px)'
                    },
                    onMouseDown: handleDragStart, onTouchStart: handleDragStart
                },
                    React.createElement(DraggableArrowIcon, { className: "w-full h-full drop-shadow-lg" })
                )
            ) : 
            React.createElement("div", { className: 'flex flex-col items-center gap-4' },
                React.createElement("p", { className: 'text-gray-400 mb-2' }, t('uploadSourceImage')),
                React.createElement("div", { className: "flex justify-center gap-4 w-full max-w-xs" },
                    React.createElement(Button, { onClick: () => fileInputRef.current?.click(), className: "p-4 aspect-square flex-1", "aria-label": t('gallery') },
                        React.createElement(GalleryIcon, { className: "w-8 h-8 mx-auto" })
                    ),
                    React.createElement(Button, { onClick: onLaunchCamera, className: "p-4 aspect-square flex-1", "aria-label": t('camera') },
                        React.createElement(CameraIcon, { className: "w-8 h-8 mx-auto" })
                    )
                )
            ),
        React.createElement("input", { ref: fileInputRef, type: "file", accept: "image/*", onChange: handleFileChange, className: "hidden" }),
        React.createElement("div", { className: 'my-4 text-left rtl:text-right' },
            React.createElement("label", { htmlFor: 'custom-prompt', className: 'font-semibold mb-2 block text-gray-300' }, t('describeItem')),
            React.createElement("textarea", {
                id: 'custom-prompt', value: promptText, onChange: (e) => setPromptText(e.target.value),
                placeholder: t('promptPlaceholder'), rows: 3,
                className: 'w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:ring-blue-500 focus:border-blue-500'
            })
        ),
        React.createElement("div", { className: "flex gap-3 mt-auto" },
            React.createElement(Button, { onClick: onClose, variant: "secondary", className: "w-full !text-sm !p-2" }, t('cancel')),
            React.createElement(Button, { onClick: handleSubmit, disabled: !isValid, className: "w-full !text-sm !p-2" }, t('apply'))
        )
    );
};
// END: components/modals/CustomItemModal.tsx

// START: components/modals/AbayaTypeModal.tsx
const AbayaTypeModal = ({ onClose, onSelect, t }) => React.createElement(ModalWrapper, { title: t('chooseAbayaType'), onClose: onClose },
  React.createElement(Button, { onClick: () => onSelect('closed'), className: "w-full !text-sm !p-2" }, t('abayaClosed')),
  React.createElement(Button, { onClick: () => onSelect('open'), className: "w-full !text-sm !p-2" }, t('abayaOpen')),
  React.createElement(Button, { onClick: onClose, variant: "secondary", className: "w-full mt-4 !text-sm !p-2" }, t('cancel'))
);
// END: components/modals/AbayaTypeModal.tsx

// START: components/modals/VirtualItemSelector.tsx
const VirtualItemSelector = ({ category, onClose, onApply, t }) => {
  const items = VIRTUAL_ITEMS[category.id] || [];
  const [selectedStyle, setSelectedStyle] = useState(items[0]?.prompt || '');
  const [color, setColor] = useState('#000000');
  
  return React.createElement(ModalWrapper, { title: `${t('chooseVirtual')} ${t(category.nameKey)}`, onClose: onClose },
    React.createElement("div", { className: "grid grid-cols-2 md:grid-cols-3 gap-2 my-4" },
      items.map(item => React.createElement("div", {
          key: item.prompt,
          className: `p-3 rounded-lg cursor-pointer transition-all duration-200 border-2 ${selectedStyle === item.prompt ? 'bg-blue-500/30 border-blue-400' : 'bg-gray-700 border-gray-600 hover:border-gray-500'}`,
          onClick: () => setSelectedStyle(item.prompt)
        },
        React.createElement("span", { className: "font-semibold" }, t(item.nameKey))
      ))
    ),
    React.createElement("div", { className: "my-4 text-left rtl:text-right" },
      React.createElement("label", { htmlFor: "color-picker", className: "font-semibold mb-2 block" }, t('chooseColor')),
      React.createElement("input", {
        id: "color-picker",
        type: "color",
        value: color,
        onChange: (e) => setColor(e.target.value),
        className: "w-full h-12 p-1 bg-gray-700 rounded-lg border-2 border-gray-600 cursor-pointer"
      })
    ),
    React.createElement("div", { className: "flex gap-3 mt-auto" },
      React.createElement(Button, { onClick: onClose, variant: "secondary", className: "w-full !text-sm !p-2" }, t('cancel')),
      React.createElement(Button, { onClick: () => onApply(`${color} ${selectedStyle}`), className: "w-full !text-sm !p-2" }, t('replace'))
    )
  );
};
// END: components/modals/VirtualItemSelector.tsx

// START: components/modals/CameraModal.tsx
const CameraModal = ({ videoRef, onCapture, onClose, t, cameraPurpose }) => React.createElement(ModalWrapper, { title: t('camera'), onClose: onClose, size: "fullscreen" },
  React.createElement("div", { className: "flex flex-col h-full" },
    React.createElement("div", { className: "relative w-full flex-1 rounded-lg overflow-hidden bg-gray-900" },
      React.createElement("video", { ref: videoRef, autoPlay: true, playsInline: true, className: "w-full h-full object-cover rounded-lg bg-gray-900" }),
      (cameraPurpose === 'clothing' || cameraPurpose === 'customItemSource') && React.createElement("div", { className: "absolute inset-0 flex items-center justify-center pointer-events-none" },
        React.createElement("div", {
          className: "w-4/5 h-4/5 border-4 border-dashed border-yellow-400/80 rounded-lg",
          style: { aspectRatio: '1/1', maxHeight: '80%', maxWidth: '80%' }
        })
      )
    ),
    React.createElement("div", { className: "flex gap-3 mt-4" },
      React.createElement(Button, { onClick: onClose, variant: "secondary", className: "w-full !text-sm !p-2" }, t('close')),
      React.createElement(Button, { onClick: onCapture, className: "w-full !text-sm !p-2" }, t('capture'))
    )
  )
);
// END: components/modals/CameraModal.tsx

// START: components/screens/GenderSelector.tsx
const GenderSelector = ({ onGenderSelect, t }) => {
  const [selected, setSelected] = useState(null);
  const [maleImage, setMaleImage] = useState(null);
  const [femaleImage, setFemaleImage] = useState(null);

  useEffect(() => {
    const cacheImage = async (key, url, setter) => {
      try {
        const cachedImage = localStorage.getItem(key);
        if (cachedImage) {
          setter(cachedImage);
          return;
        }
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        const blob = await response.blob();
        
        const reader = new FileReader();
        reader.onloadend = () => {
          const base64data = reader.result;
          try {
            localStorage.setItem(key, base64data);
          } catch (e) {
            console.error("Could not cache image in localStorage:", e);
          }
          setter(base64data);
        };
        reader.readAsDataURL(blob);
      } catch (error) {
        console.error('Failed to cache image:', error);
        setter(url);
      }
    };

    cacheImage('cached_male_gender_image', 'https://raw.githubusercontent.com/mortdha/mlabs/main/Gemini_Generated_Image_fi314tfi314tfi31%20(1).png', setMaleImage);
    cacheImage('cached_female_gender_image', 'https://raw.githubusercontent.com/mortdha/mlabs/main/2025-09-08_032925.png', setFemaleImage);
  }, []);

  const handleClick = (gender) => {
    if (selected) return;
    setSelected(gender);
    setTimeout(() => {
      onGenderSelect(gender);
    }, 500);
  };
  
  const baseImageClasses = "w-56 h-auto object-contain cursor-pointer transition-transform duration-500 ease-in-out";
  const maleImageClasses = `${baseImageClasses} transform translate-x-16 ${selected === 'male' ? 'scale-110' : ''}`;
  const femaleImageClasses = `${baseImageClasses} transform -translate-x-16 ${selected === 'female' ? 'scale-110' : ''}`;

  return React.createElement("div", { className: "flex flex-col items-center justify-center animate-fade-in w-full py-8" },
    maleImage && React.createElement("img", { onClick: () => handleClick('male'), src: maleImage, alt: t('male'), className: maleImageClasses }),
    femaleImage && React.createElement("img", { onClick: () => handleClick('female'), src: femaleImage, alt: t('female'), className: femaleImageClasses })
  );
};
// END: components/screens/GenderSelector.tsx

// START: components/screens/ImageUploader.tsx
const ImageUploader = ({ onFileSelect, onCameraSelect, t }) => {
  const fileInputRef = useRef(null);
  
  return React.createElement("div", { className: "flex flex-col items-center justify-center animate-fade-in min-h-[50vh]" },
    React.createElement("h2", { className: "text-2xl font-semibold mb-8 text-gray-200" }, t('nextStep')),
    React.createElement("div", { className: "flex flex-col gap-4 w-full max-w-xs" },
      React.createElement(Button, {
        onClick: () => fileInputRef.current?.click(),
        className: "p-5 text-lg flex items-center justify-center gap-4",
        "aria-label": t('gallery')
      },
        React.createElement(GalleryIcon, { className: "w-10 h-10" }),
        React.createElement("span", null, t('gallery'))
      ),
      React.createElement(Button, {
        onClick: onCameraSelect,
        variant: "secondary",
        className: "p-5 text-lg flex items-center justify-center gap-4",
        "aria-label": t('camera')
      },
        React.createElement(CameraIcon, { className: "w-10 h-10" }),
        React.createElement("span", null, t('camera'))
      )
    ),
    React.createElement("input", {
      ref: fileInputRef,
      type: "file",
      accept: "image/*",
      onChange: onFileSelect,
      className: "hidden"
    })
  );
};
// END: components/screens/ImageUploader.tsx

// START: components/screens/Editor.tsx
const ClothingIcons = ({ gender, onIconClick, t, disabled }) => {
  const categories = gender === 'male' ? MALE_CATEGORIES : FEMALE_CATEGORIES;
  return React.createElement("div", { className: "grid grid-cols-5 sm:grid-cols-7 md:grid-cols-9 gap-2 w-full max-w-2xl" },
    categories.map(cat => {
      const IconComponent = IconsMap[cat.icon];
      if (!IconComponent) return null;
      return React.createElement("button", {
        key: cat.id,
        className: "flex flex-col items-center justify-center p-1 bg-gray-700 rounded-lg hover:bg-blue-500/50 hover:border-blue-400 border-2 border-transparent transition-all duration-200 aspect-square group disabled:opacity-50 disabled:pointer-events-none disabled:hover:bg-gray-700",
        onClick: () => onIconClick(cat),
        "aria-label": `${t('changing')} ${t(cat.nameKey)}`,
        disabled: disabled
      },
        React.createElement("div", { className: "w-7 h-7 text-blue-400 group-hover:text-white transition-colors duration-200" }, React.createElement(IconComponent)),
        React.createElement("span", { className: "mt-1 text-[10px] leading-tight font-semibold text-gray-300 group-hover:text-white transition-colors duration-200 text-center" }, t(cat.nameKey))
      );
    })
  );
};

const Editor = ({
  editedImage, gender, isLoading, loadingMessage, canUndo, canRedo, t,
  onIconClick, onRevert, onUndo, onRedo, onDownload, onImageDoubleClick
}) => React.createElement("div", { className: "w-full flex flex-col items-center" },
  React.createElement("div", { className: "relative w-full max-w-5xl mb-2 flex justify-center items-center h-[60vh]" },
    isLoading && React.createElement("div", { className: "absolute inset-0 bg-gray-900/80 flex flex-col items-center justify-center z-10 backdrop-blur-sm" },
      React.createElement(Spinner),
      React.createElement("p", { className: "mt-4 text-lg font-semibold text-blue-400" }, loadingMessage)
    ),
    editedImage && React.createElement("img", {
      src: `data:${editedImage.mimeType};base64,${editedImage.data}`,
      alt: "Model",
      className: "max-w-full max-h-full object-contain rounded-xl cursor-pointer",
      onDoubleClick: onImageDoubleClick
    })
  ),
  React.createElement(ClothingIcons, { gender: gender, onIconClick: onIconClick, t: t, disabled: isLoading }),
  React.createElement("div", { className: "flex flex-wrap justify-center gap-2 mt-4" },
    React.createElement(Button, { onClick: onUndo, variant: "secondary", disabled: !canUndo || isLoading }, t('undo')),
    React.createElement(Button, { onClick: onRedo, variant: "secondary", disabled: !canRedo || isLoading }, t('redo')),
    React.createElement(Button, { onClick: onRevert, variant: "secondary", disabled: !canUndo || isLoading }, t('reset')),
    React.createElement(Button, { onClick: onDownload, disabled: isLoading }, t('save'))
  )
);
// END: components/screens/Editor.tsx

// START: components/modals/PreviewModal.tsx
const PreviewModal = ({ onClose, onConfirm, t, previewImage }) => {
  return React.createElement(ModalWrapper, { onClose: onClose },
    React.createElement("div", { className: "flex flex-col items-center justify-center gap-4" },
      React.createElement("div", { className: "w-full max-w-xs border-2 border-dashed border-gray-600 rounded-lg overflow-hidden" },
        React.createElement("img", { src: previewImage, alt: t('chooseSourceFor'), className: "w-full h-auto object-contain" })
      ),
      React.createElement("div", { className: "flex gap-3 mt-4 w-full" },
        React.createElement(Button, { onClick: onClose, variant: "secondary", className: "w-full !text-sm !p-2" }, t('back')),
        React.createElement(Button, { onClick: onConfirm, className: "w-full !text-sm !p-2 flex items-center justify-center" }, t('replace'))
      )
    )
  );
};
// END: components/modals/PreviewModal.tsx

// START: App.tsx
const App = () => {
    const { language, setLanguage, t, getNextLangName } = useLocalization();
    const { apiKey, setApiKey, toastMessage, setToastMessage, handleSaveKey } = useApiKey(t);

    const [originalImage, setOriginalImage] = useState(null);
    const [editedImage, setEditedImage] = useState(null);
    const [history, setHistory] = useState([]);
    const [redoStack, setRedoStack] = useState([]);
    const [wornItems, setWornItems] = useState([]);
    const [gender, setGender] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [loadingMessage, setLoadingMessage] = useState('');
    const [modal, setModal] = useState('closed');
    const [currentCategory, setCurrentCategory] = useState(null);
    const [cameraPurpose, setCameraPurpose] = useState(null);
    const [customItemSourceFile, setCustomItemSourceFile] = useState(null);
    const [isImageZoomed, setIsImageZoomed] = useState(false);

    const [previewImage, setPreviewImage] = useState(null);
    const pendingGeneration = useRef(null);
    
    const galleryInputRef = useRef(null);
    const galleryCategoryRef = useRef(null);
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const backPressTimer = useRef(null);

    useEffect(() => {
        const handlePopState = () => {
            if (originalImage) {
                setOriginalImage(null); setEditedImage(null); setHistory([]); setWornItems([]);
                window.history.pushState({ screen: 'uploader' }, '');
            } else if (gender) {
                setGender(null);
                window.history.pushState({ screen: 'gender' }, '');
            } else {
                 if (backPressTimer.current) {
                    clearTimeout(backPressTimer.current); window.close();
                } else {
                    setToastMessage(t('pressBackAgainToExit'));
                    backPressTimer.current = window.setTimeout(() => { setToastMessage(''); backPressTimer.current = null; }, 2000);
                    window.history.pushState(null, '', window.location.href);
                }
            }
        };

        window.addEventListener('popstate', handlePopState);
        return () => {
            window.removeEventListener('popstate', handlePopState);
            if (backPressTimer.current) clearTimeout(backPressTimer.current);
        };
    }, [gender, originalImage, t, setToastMessage]);

    useEffect(() => {
        if (!window.history.state?.screen) {
            window.history.replaceState({ screen: 'gender' }, '');
        }
    }, []);

    const stopCamera = useCallback(() => {
        if (videoRef.current?.srcObject) {
            const stream = videoRef.current.srcObject;
            stream.getTracks().forEach(track => track.stop());
            videoRef.current.srcObject = null;
        }
    }, []);

    useEffect(() => {
        const openCamera = async () => {
            if (modal !== 'camera') return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } } });
                if (videoRef.current) videoRef.current.srcObject = stream;
            } catch (err) {
                alert(t('cameraError')); setModal('closed');
            }
        };
        openCamera();
        return stopCamera;
    }, [modal, stopCamera, t]);

    const handleInitialFileSelect = useCallback(async (file) => {
        if (!file) return;
        try {
            const base64Data = await toBase64(file);
            const imageState = { data: base64Data, mimeType: file.type };
            setOriginalImage(imageState);
            setEditedImage(imageState);
            setHistory([]);
            setWornItems([]);
            setRedoStack([]);
            window.history.pushState({ screen: 'editor' }, '');
        } catch (error) {
            alert(t('imageLoadError'));
        }
    }, [t]);
    
    const handleDirectGeneration = useCallback(async (category, options) => {
        if (!editedImage) { alert(t('uploadFirst')); return; }
        if (!apiKey) { alert(t('apiKeyMissing')); return; }
        
        const femaleOnlyItems = ['hijab', 'abaya', 'dress', 'jubba', 'handbag', 'chador'];
        const maleOnlyItems = ['tie', 'dishdasha'];

        if (gender === 'male' && femaleOnlyItems.includes(category.id)) {
            alert(`${t('misuseWarningTitle')}\n\n${t('misuseWarningBody')}`);
            setModal('closed'); return;
        }
        if (gender === 'female' && maleOnlyItems.includes(category.id)) {
            alert(`${t('misuseWarningTitle')}\n\n${t('misuseWarningBody')}`);
            setModal('closed'); return;
        }

        const isReplacing = category.id !== 'customItem' && wornItems.includes(category.id);
        setHistory(prev => [...prev, { image: editedImage, wornItems }]);
        setIsLoading(true);
        setLoadingMessage(t('loading'));
        setModal('closed');

        try {
            let clothingImagePart;
            if (options.clothingFile) {
                clothingImagePart = { data: await toBase64(options.clothingFile), mimeType: options.clothingFile.type };
            }
            
            const resultBase64 = await generateImage(apiKey, editedImage, clothingImagePart, category, options, wornItems, gender, isReplacing);
            
            setEditedImage({ data: resultBase64, mimeType: 'image/png' });
            if (!isReplacing) setWornItems(prev => [...new Set([...prev, category.id])]);
            setRedoStack([]);
            
        } catch (error) {
            const errKey = error instanceof Error ? error.message : 'unexpectedError';
            const displayMessage = t(errKey) ? t(errKey) : t('apiError').replace('{message}', errKey);
            alert(displayMessage);
            if (errKey === 'API_KEY_MISSING') {
                localStorage.removeItem('gemini_api_key'); setApiKey(null);
            }
            setHistory(prev => prev.slice(0, -1));
        } finally {
            setIsLoading(false);
            if(category.id === 'customItem') setCustomItemSourceFile(null);
        }
    }, [editedImage, apiKey, wornItems, gender, t, setApiKey]);

    const startPreemptiveGeneration = useCallback(async (category, options) => {
        if (!editedImage || !apiKey || !options.clothingFile) return;

        const isReplacing = category.id !== 'customItem' && wornItems.includes(category.id);
        const clothingFile = options.clothingFile;

        const reader = new FileReader();
        reader.readAsDataURL(clothingFile);
        reader.onload = () => setPreviewImage(reader.result);
        
        setModal('preview');
        galleryCategoryRef.current = category;

        pendingGeneration.current = (async () => {
            const clothingImagePart = { data: await toBase64(clothingFile), mimeType: clothingFile.type };
            return generateImage(apiKey, editedImage, clothingImagePart, category, options, wornItems, gender, isReplacing);
        })();

        pendingGeneration.current.catch(error => {
            console.error("Preemptive generation failed:", error);
        });

    }, [editedImage, apiKey, wornItems, gender]);

    const handleConfirmGeneration = useCallback(async () => {
        if (!pendingGeneration.current || !editedImage || !galleryCategoryRef.current) return;
        
        const category = galleryCategoryRef.current;
        const isReplacing = category.id !== 'customItem' && wornItems.includes(category.id);
        
        setModal('closed');
        setIsLoading(true);
        setLoadingMessage(t('loading'));
        
        try {
            const resultBase64 = await pendingGeneration.current;

            setHistory(prev => [...prev, { image: editedImage, wornItems }]);
            setEditedImage({ data: resultBase64, mimeType: 'image/png' });
            if (!isReplacing) {
                setWornItems(prev => [...new Set([...prev, category.id])]);
            }
            setRedoStack([]);
        } catch (error) {
            const errKey = error instanceof Error ? error.message : 'unexpectedError';
            const displayMessage = t(errKey) ? t(errKey) : t('apiError').replace('{message}', errKey);
            alert(displayMessage);
        } finally {
            setIsLoading(false);
            setPreviewImage(null);
            pendingGeneration.current = null;
            galleryCategoryRef.current = null;
        }
    }, [editedImage, wornItems, t]);

    const handleCancelGeneration = () => {
        setModal('closed');
        setPreviewImage(null);
        pendingGeneration.current = null;
        galleryCategoryRef.current = null;
    };
    
    const handleGalleryFileChange = useCallback(async (e) => {
        const file = e.target.files?.[0];
        const category = galleryCategoryRef.current;
        if (file && category) {
            await startPreemptiveGeneration(category, { clothingFile: file });
        }
        if (e.target) e.target.value = null;
    }, [startPreemptiveGeneration]);

    const handleGallerySelect = useCallback(() => {
        if (!currentCategory) return;
        galleryCategoryRef.current = currentCategory;
        galleryInputRef.current?.click();
    }, [currentCategory]);

    const startCamera = (purpose) => {
        setCameraPurpose(purpose);
        setModal('camera');
    };

    const handleCapture = useCallback(() => {
        if (!videoRef.current || !canvasRef.current) return;
        
        const video = videoRef.current;
        const canvas = canvasRef.current;
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const context = canvas.getContext('2d');
        if (!context) return;
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        setModal('closed');

        const processFile = (file) => {
            if (cameraPurpose === 'clothing' && currentCategory) startPreemptiveGeneration(currentCategory, { clothingFile: file });
            else if (cameraPurpose === 'customItemSource') { setCustomItemSourceFile(file); setModal('custom'); }
        };

        if (cameraPurpose === 'initial') {
            canvas.toBlob(blob => {
                if(blob) handleInitialFileSelect(new File([blob], "capture.jpg", { type: "image/jpeg" }));
            }, 'image/jpeg');
        } else if (cameraPurpose === 'clothing' || cameraPurpose === 'customItemSource') {
            const scaleX = video.videoWidth / video.clientWidth;
            const scaleY = video.videoHeight / video.clientHeight;
            const frameSizePx = Math.min(video.clientWidth, video.clientHeight) * 0.8;
            const sx = ((video.clientWidth - frameSizePx) / 2) * scaleX;
            const sy = ((video.clientHeight - frameSizePx) / 2) * scaleY;
            const sWidth = frameSizePx * scaleX;
            const sHeight = frameSizePx * scaleY;

            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = sWidth;
            cropCanvas.height = sHeight;
            cropCanvas.getContext('2d')?.drawImage(canvas, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
            cropCanvas.toBlob(blob => {
                if (blob) processFile(new File([blob], "capture.jpg", { type: "image/jpeg" }));
            }, 'image/jpeg');
        }
    }, [cameraPurpose, currentCategory, handleInitialFileSelect, startPreemptiveGeneration]);

    const handleGenderSelect = (g) => {
        setGender(g);
        window.history.pushState({ screen: 'uploader' }, '');
    };
    
    const handleIconClick = (category) => {
        setCurrentCategory(category);
        setModal(category.id === 'customItem' ? 'custom' : 'source');
    };

    const handleUndo = () => {
        if (history.length > 0 && editedImage) {
            setRedoStack(prev => [{ image: editedImage, wornItems }, ...prev]);
            const lastState = history[history.length - 1];
            setEditedImage(lastState.image);
            setWornItems(lastState.wornItems);
            setHistory(history.slice(0, -1));
        }
    };

    const handleRedo = () => {
        if (redoStack.length > 0 && editedImage) {
            const stateToRestore = redoStack[0];
            const remainingRedoStack = redoStack.slice(1);

            if (!stateToRestore.fullHistory) {
                setHistory(prev => [...prev, { image: editedImage, wornItems }]);
            }

            setEditedImage(stateToRestore.image);
            setWornItems(stateToRestore.wornItems);

            if (stateToRestore.fullHistory) {
                setHistory(stateToRestore.fullHistory);
            }
            setRedoStack(remainingRedoStack);
        }
    };

    const handleRevert = () => {
        if (editedImage) {
            setRedoStack([{ image: editedImage, wornItems, fullHistory: history }]);
            setEditedImage(originalImage);
            setHistory([]);
            setWornItems([]);
        }
    };

    const handleDownload = () => {
        if (editedImage) {
            const link = document.createElement('a');
            link.href = `data:${editedImage.mimeType};base64,${editedImage.data}`;
            link.download = 'edited_image.png';
            link.click();
        }
    };
    
    const renderContent = () => {
        if (!apiKey) return React.createElement("div", { className: "text-center p-12" },
            React.createElement("h2", { className: "text-2xl font-bold text-yellow-400 mb-2" }, t('apiKeyMissingTitle')),
            React.createElement("p", { className: "text-gray-300" }, t('apiKeyMissingDesc'))
        );
        if (!gender) return React.createElement(GenderSelector, { onGenderSelect: handleGenderSelect, t: t });
        if (!originalImage) return React.createElement(ImageUploader, { onFileSelect: (e) => handleInitialFileSelect(e.target.files?.[0] || null), onCameraSelect: () => startCamera('initial'), t: t });
        return React.createElement(Editor, {
            editedImage: editedImage, gender: gender, isLoading: isLoading, loadingMessage: loadingMessage, 
            canUndo: history.length > 0, canRedo: redoStack.length > 0, t: t,
            onImageDoubleClick: () => setIsImageZoomed(true), onIconClick: handleIconClick, 
            onRevert: handleRevert, onUndo: handleUndo, onRedo: handleRedo, onDownload: handleDownload
        });
    };

    return React.createElement("main", { className: "min-h-screen w-full flex flex-col items-center p-4" },
        !originalImage && !gender && React.createElement("header", { className: "w-full max-w-4xl relative h-12 mb-4" },
            React.createElement("button", { onClick: () => setLanguage(lang => lang === 'ar' ? 'en' : lang === 'en' ? 'fa' : 'ar'), className: "absolute top-1/2 -translate-y-1/2 left-0 bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-200 text-sm" }, getNextLangName()),
            React.createElement("h1", { className: "absolute top-1/2 -translate-y-1/2 right-0 text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500" }, t('appTitle'))
        ),
        React.createElement("div", { className: `w-full max-w-4xl mx-auto text-center transition-all duration-500 ${originalImage ? 'pt-6' : ''}` },
            renderContent(),
            modal === 'source' && currentCategory && React.createElement(InputSourceModal, {
                category: currentCategory, t: t, onClose: () => setModal('closed'),
                onGallerySelect: handleGallerySelect,
                onCameraSelect: () => startCamera('clothing'),
                onVirtualSelect: () => setModal(currentCategory?.id === 'abaya' ? 'abaya' : 'virtual')
            }),
            modal === 'custom' && currentCategory && React.createElement(CustomItemModal, {
                t: t, 
                onClose: () => { setModal('closed'); setCustomItemSourceFile(null); }, 
                onSubmit: (options) => handleDirectGeneration(currentCategory, options), 
                onLaunchCamera: () => startCamera('customItemSource'), 
                initialSourceFile: customItemSourceFile 
            }),
            modal === 'virtual' && currentCategory && React.createElement(VirtualItemSelector, {
                category: currentCategory, t: t, onClose: () => setModal('closed'), 
                onApply: (prompt) => handleDirectGeneration(currentCategory, { virtualPrompt: prompt }) 
            }),
            modal === 'abaya' && currentCategory && React.createElement(AbayaTypeModal, {
                t: t, onClose: () => setModal('closed'), 
                onSelect: (type) => handleDirectGeneration(currentCategory, { abayaType: type }) 
            }),
            modal === 'camera' && React.createElement(CameraModal, {
                videoRef: videoRef, t: t, 
                onCapture: handleCapture, 
                onClose: () => setModal('closed'), 
                cameraPurpose: cameraPurpose 
            }),
            modal === 'preview' && previewImage && React.createElement(PreviewModal, {
                t: t,
                previewImage: previewImage,
                onClose: handleCancelGeneration,
                onConfirm: handleConfirmGeneration
            }),
            React.createElement("canvas", { ref: canvasRef, className: "hidden" }),
            React.createElement("input", {
                ref: galleryInputRef,
                type: "file",
                accept: "image/*",
                className: "hidden",
                onChange: handleGalleryFileChange
            })
        ),
        isImageZoomed && editedImage && React.createElement("div", { className: "fixed inset-0 bg-black/90 flex items-center justify-center z-[100] animate-fade-in", onDoubleClick: () => setIsImageZoomed(false) },
            React.createElement("img", { src: `data:${editedImage.mimeType};base64,${editedImage.data}`, alt: "Zoomed Model", className: "max-w-full max-h-full object-contain" })
        ),
        !gender && !originalImage && React.createElement(React.Fragment, null,
            React.createElement(ApiKeyManager, { t: t, onSave: handleSaveKey, currentKey: apiKey }),
            React.createElement("footer", { className: "w-full max-w-4xl mx-auto mt-4 text-center text-gray-500 text-sm" },
                `© ${new Date().getFullYear()} `,
                React.createElement("a", { href: "https://t.me/Mortdh190", target: "_blank", rel: "noopener noreferrer", className: "underline hover:text-gray-400" }, "مرتضى الدحيدحاوي")
            )
        ),
        toastMessage && React.createElement("div", { className: "fixed bottom-10 left-1/2 -translate-x-1/2 bg-gray-800/90 text-white px-4 py-2 rounded-lg shadow-lg animate-fade-in z-[100]" }, toastMessage)
    );
};
// END: App.tsx

// START: index.tsx (Entry Point)
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(
  React.createElement(React.StrictMode, null, React.createElement(App))
);
// END: index.tsx
</script>
  </body>
</html>
